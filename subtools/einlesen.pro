;----------------------------------------------------------------------------------
function type_conversion , value, type
	dummy = -1l
	case type of
		0	: bla   = temporary(dummy)
		1	: dummy = byte     (value)
		2	: dummy = fix      (value)
		3	: dummy = long     (value)
		4	: dummy = float    (value)
		5	: dummy = double   (value)
		6	: dummy = complex  (value)
		7	: dummy = string   (value)
		8	: dummy = {value : value}
		9	: dummy = dcomplex (value) 
		10	: dummy = ptr_new  (value)
		11	: dummy = obj_new  (value)
		12	: dummy = uint     (value)
		13	: dummy = ulong    (value)
		14	: dummy = long64   (value)
		15	: dummy = ulong64  (value)
		else	: print, 'Unknown type!'+strcompress(type) 
	endcase
	return, dummy
end
;----------------------------------------------------------------------------------
function str_rem, zeile, remove
	dum_zeile = zeile
	if keyword_set(remove) then begin
		for i=0,n_elements(remove)-1 do begin
			dum_zeile=strjoin(strsplit(dum_zeile,remove[i],/ext,/regex))
		endfor
	endif 
	return, dum_zeile
end
;----------------------------------------------------------------------------------

; einlesen.pro
;
; slightly changed matrix_einlesen.pro from Max Reuter
;
; reads also gzipped files
;
; additional keywords:
;	remove		: removes defined strings from each line of the input file 
;			  e.g. 	remove = ['\*','\+'] removes * and +
;				remove = ['[a-z]+','[0-9]+','/'] removes all small letters and numbers and '/'
;	predict		: especially for textfiles generated by predict
;	start		: number of the first line to read (start from 0)
;			  if start is a string then the file will be searched for the string
;			  if found then reading matrix will start at next line after matching string
;			  e.g. start = 'Mapping Function' : reads mapping function from *.ck files
;	ende		: number of line until matrix will be read (start from 0)
;			  if ende is a string then the file will be searched for the string
;			  if found then reading matrix will stop at first line with matching string
;			  e.g. stop = 'EEooFF' : reads until it finds 'EEooFF' 
;	print		: simply prints all of the file  
; 	comment		: choose one or more single! character(s) that comments a line , default is [';','#'] 

function  einlesen,  file ,	long	  = long	,$
				l64	  = l64		,$
				integer	  = integer	,$
				byte	  = byte	,$
				float	  = float	,$
				double	  = double	,$
				string	  = string	,$
				uint	  = uint	,$
				ulong	  = ulong	,$
				ul64	  = ul64	,$
				start	  = start	,$
				ende	  = ende	,$
				num_lines = num_lines	,$
				delimiter = delimiter	,$
				remove	  = remove	,$
				comment   = comment	,$
				predict	  = predict	,$
				grep_line = grep_line	,$
				grep_all  = grep_all	,$
				print     = print	,$
				help	  = help

	if keyword_set(help) then return, einlesen(print='this_file',start = 36, ende = 'this_file', remove = ';')

	if ~file_test(file) then begin
		print,'File not Found! '+file
		return, -1l
	endif

	error = 0
	catch, error
	if (error ne 0) then begin
		print,"   # "+!ERROR_STATE.msg
		print,"   # "+!ERROR_STATE.sys_msg
		print,""
		print,"   # Syntax error? Try keyword 'help'"
		if keyword_set(lun) then free_lun,lun,/force
		return, -1l
	endif

	if file_lines(file,compress = is_compressed(file)) eq 0 then begin
		print,'File empty! '+file
		return,-1l
	endif

	type = 4
	if keyword_set(predict) then begin
 		remove = ['Dec','Mon','Tue','Wed','Thu','Fri','Sat','Sun','\*','\+']
		type   = 3
	endif
	if 	keyword_set(byte)	then type =  1
	if 	keyword_set(integer)	then type =  2
	if 	keyword_set(long)	then type =  3
	if 	keyword_set(float)	then type =  4
	if 	keyword_set(double)	then type =  5
	if 	keyword_set(string)	then type =  7
	if 	keyword_set(uint)	then type = 12
	if 	keyword_set(ulong)	then type = 13
	if 	keyword_set(l64)	then type = 14
	if 	keyword_set(ul64)	then type = 15
	if keyword_set(print) then if strlowcase(print) eq 'this_file' then begin
		help,/traceback, out = help_info
		file = (strsplit(help_info[1],/ext))[3]
	endif
	start     = keyword_set(start)     ? start     : 0ul
	ende      = keyword_set(ende)      ? ende      : file_lines(file,compress = is_compressed(file))
	delimiter = keyword_set(delimiter) ? delimiter : " "
	comment   = keyword_set(comment)   ? comment   : [";","#"]

	if size(ende,/type) eq 7l then begin
		zeile = "" & cende = 0ul
		openr, lun, file, /get_lun,compress = is_compressed(file)
		while not eof(lun) do begin
			readf, lun, zeile
			if stregex(zeile,ende,/boolean,/fold_case) then break
			cende++
		endwhile
		ende = cende -1
		free_lun,lun,/force
	endif

	ende -= 1ul
	zeile = "" & count   = 0ul
	openr, lun, file, /get_lun,compress = is_compressed(file)
	if eof(lun) then begin
		print,'File empty! '+file
		free_lun,lun,/force
		return,-1l
	endif

	;start is string?
	if size(start,/type) eq 7l then begin
		while not eof(lun) do begin
			readf, lun, zeile
			if stregex(zeile,start,/boolean,/fold_case) then break
			count++
		endwhile
	endif else begin
		for i = 1l, start do begin
			if eof(lun) then begin
				free_lun,lun,/force
				return,-1l
			endif
			readf, lun, zeile
			count++
		endfor
; 		count -= 1ul
	endelse
	if eof(lun) then begin
		free_lun,lun,/force
		return,-1l
	endif

	if keyword_set(grep_line) or keyword_set(grep_all) then begin
		if keyword_set(grep_all) then grep_line = grep_all
		while not eof(lun) do begin
			readf,lun,zeile
			if stregex(zeile,grep_line[0],/boolean,/fold_case) then begin
				if ~keyword_set(grep_all) then begin 
					free_lun,lun,/force
					return,zeile
				endif
				out = size(out,/type) eq 0 ? zeile:[out,zeile]
			endif
		endwhile
		free_lun,lun,/force
		return, ( size(out,/type) eq 0 ? -1l : out )
	endif

	if keyword_set(print) then begin
		while not eof(lun) and (count le ende) do begin
			readf,lun,zeile & count++
			print,str_rem(zeile, remove)
		endwhile
		free_lun,lun,/force
		return, -1l
	endif
	readf, lun, zeile ;& count++

; 	while ((not eof(lun)) and ((strmid(strtrim(zeile,1),0,1) eq ";") 	$
; 	or (strmid(strtrim(zeile,1),0,1) eq "#") or (zeile eq ''))) do begin
	while ((not eof(lun)) and total((strmid(strtrim(zeile, 1), 0, 1) eq comment)) or (zeile eq '')) do begin
		readf, lun, zeile & count++
	endwhile
	zeile = str_rem(zeile, remove)

	if keyword_set(num_lines) then ende = count+num_lines-1

	if count gt ende then begin
	print,'count gt ende'
		free_lun,lun,/force
		return, -1l
	endif
	zaehler      = 1l
	zeilen_array = type_conversion(strsplit(strcompress(strtrim(zeile,2)), delimiter, /extract), type)
	spalten      = n_elements(zeilen_array)
	zeiger       = ptr_new({daten:zeilen_array, next:ptr_new()})
	position     = zeiger

	while (not eof(lun)) and (count lt ende) do begin
		readf, lun, zeile & count++
		zeile = str_rem(zeile, remove)
; 		if not total((strmid(strtrim(zeile, 1), 0, 1) eq [";","#"])) then begin
		if not total((strmid(strtrim(zeile, 1), 0, 1) eq comment)) then begin
			zeilen_array = type_conversion(strsplit(strcompress(strtrim(zeile,2)), delimiter, /extract), type)
			; fill with NANs if zeilen_array has less columns than spalten; break if it has more
			if (n_elements(zeilen_array) le spalten) then begin
				if (n_elements(zeilen_array) lt spalten) then begin
					dum = make_array(spalten,1,type=type,value=!VALUES.F_NAN)
					dum[0:n_elements(zeilen_array)-1] = zeilen_array
					zeilen_array = dum
				endif
; 			if (n_elements(zeilen_array) eq spalten) then begin
				(*position).next = ptr_new({daten:zeilen_array, next:ptr_new()})
				position = (*position).next
				zaehler++
			endif else begin
				ende = 1
			endelse
		endif
	endwhile

	matrix = make_array (spalten, zaehler, type = type)

	position = zeiger
	for i = 0l, zaehler - 1 do begin
		matrix[*,i] = (*position).daten
		position = (*position).next
	endfor

	advanced_ptr_free, zeiger
	advanced_ptr_free, position
	free_lun, lun,/force

	return, matrix

end
